## 5. Readable and efficient code
Read over the code below.
```{r}
set.seed(1)
x <- rnorm(1000)
y <- 2 + x + rnorm(1000)
df <- data.frame(x, y)

cat("Step", 1, "\n")
fit1 <- lm(y ~ x, data = df[-(1:250),])
p1 <- predict(fit1, newdata = df[(1:250),])
r <- sqrt(mean((p1 - df[(1:250),"y"])^2))

cat("Step", 2, "\n")
fit2 <- lm(y ~ x, data = df[-(251:500),])
p2 <- predict(fit2, newdata = df[(251:500),])
r <- c(r, sqrt(mean((p2 - df[(251:500),"y"])^2)))

cat("Step", 3, "\n")
fit3 <- lm(y ~ x, data = df[-(501:750),])
p3 <- predict(fit3, newdata = df[(501:750),])
r <- c(r, sqrt(mean((p3 - df[(501:750),"y"])^2)))

cat("Step", 4, "\n")
fit4 <- lm(y ~ x, data = df[-(751:1000),])
p4 <- predict(fit4, newdata = df[(751:1000),])
r <- c(r, sqrt(mean((p4 - df[(751:1000),"y"])^2)))
r
```

### a.
Explain (in text) what the code does.

This code first takes samples of two normally distributed random variables.Then, multiple linear models are calculated, based on different portions of the input data. Afterwards, those models are used to predict that portion of the data, that has not been used to train the models. Finally, the mean squared error is appended to a list and printed out.

### b.
Explain (in text) what you would change to make the code more readable.

While achieving its purpose, the code is not structured in an optimal way. First, there is a lot of repetition, which violates the DRY (Don't Repeat Yourself) Principle. To mitigate this, I would suggest refactoring by putting repeated code segments in a dedicated function. Then, the variable representing the mean squared errors is named "r". While this might not be an explicit problem, I would prefer to rename this to a more clear name.

### c.
Change the code according to a. and wrap it in a function. This function should have at most 10 lines (without adding commands to more lines such as x <- 1; y <- 2. Such commands will count as 2 lines!).
Check that the function called on the same input outputs the same as the provided code.

```{r}
getLinearModelMeanSquaredError <- function(data, testingRange) {
  fit <- lm(y ~ x, data = data[-testingRange,])
  prediction <- predict(fit, newdata = data[testingRange,])
  return(sqrt(mean((prediction - data[testingRange, "y"])^2)))
}

set.seed(1)
x <- rnorm(1000)
y <- 2 + x + rnorm(1000)
df <- data.frame(x, y)

indices <- list(c(1:250), c(251:500), c(501:750), c(751:1000))
errors <- unlist(lapply(indices, function(i) getLinearModelMeanSquaredError(df, i)))
print(errors)
```