## 6. Measuring and improving performance

```{r warning=FALSE}

if (!requireNamespace("bench", quietly = TRUE)) {
  install.packages("bench")
}
library(bench)

```

Have a look at the code of the function below. It is a function for performing a Kruskal Wallis test, a robust non-parametric method for testing whether samples come from the same distribution. (Note: we assume no missing values are present in x).
```{r}
kwtest <- function (x, g, ...) {
  if (is.list(x)) {
    if (length(x) < 2L)
      stop("'x' must be a list with at least 2 elements")
    if (!missing(g))
      warning("'x' is a list, so ignoring argument 'g'")
    if (!all(sapply(x, is.numeric)))
      warning(
        "some elements of 'x' are not numeric and will be coerced to numeric"
        )
    k <- length(x)
    l <- lengths(x)
    if (any(l == 0L))
      stop("all groups must contain data")
    g <- factor(rep.int(seq_len(k), l))
    x <- unlist(x)
  } else {
    if (length(x) != length(g))
      stop("'x' and 'g' must have the same length")
    g <- factor(g)
    k <- nlevels(g)
    if (k < 2L)
      stop("all observations are in the same group")
  }
  n <- length(x)
  if (n < 2L)
    stop("not enough observations")
  r <- rank(x)
  TIES <- table(x)
  STATISTIC <- sum(tapply(r, g, sum)^2/tapply(r, g, length))
  STATISTIC <- (
    (12 * STATISTIC/(n * (n + 1)) - 3 * (n + 1))/
      (1 -sum(TIES^3 - TIES)/(n^3 - n))
    )
  PARAMETER <- k - 1L
  PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
  names(STATISTIC) <- "Kruskal-Wallis chi-squared"
  names(PARAMETER) <- "df"
  RVAL <- list(statistic = STATISTIC, parameter = PARAMETER,
  p.value = PVAL, method = "Kruskal-Wallis rank sum test")
  return(RVAL)
}
```


### a.
Write a pseudo code outlining what the function does.
```
Function kwtest(x, g, ...)
    If x is a list Then
        If length of x is less than 2 Then
            Stop with error "'x' must be a list with at least 2 elements"
        End If
        If g is not missing Then
            Issue warning "'x' is a list, so ignoring argument 'g'"
        End If
        If not all elements of x are numeric Then
            Issue warning "some elements of 'x' are not numeric and will be 
            coerced to numeric"
        End If
        Set k to length of x
        Set l to lengths of x
        If any element of l is 0 Then
            Stop with error "all groups must contain data"
        End If
        Set g to factor with levels as sequence from 1 to k, repeated l times
        Unlist x
    Else
        If length of x is not equal to length of g Then
            Stop with error "'x' and 'g' must have the same length"
        End If
        Set g to factor of g
        Set k to number of levels in g
        If k is less than 2 Then
            Stop with error "all observations are in the same group"
        End If
    End If
    Set n to length of x
    If n is less than 2 Then
        Stop with error "not enough observations"
    End If
    Set r to rank of x
    Set TIES to Create a table of x
    Calculate STATISTIC as sum of squares of ranks in each group divided by the 
      number of ranks in each group
    Adjust STATISTIC based on the formula provided
    Set PARAMETER to k - 1
    Calculate PVAL as the p-value of the chi-squared distribution with PARAMETER 
      degrees of freedom and STATISTIC, using the upper tail
    Set names of STATISTIC and PARAMETER to "Kruskal-Wallis chi-squared" and 
      "df" respectively
    Create a list RVAL with statistic, parameter, p.value, and method
    Return RVAL
End Function
```

### b.
For example data, call the function in two ways: once using x as a list and once using x as a vector with a corresponding g argument. Ensure that the two different function calls return the same thing by aligning the inputs.
```{r}
data("PlantGrowth")
group1 <- PlantGrowth$weight[PlantGrowth$group == "ctrl"]
group2 <- PlantGrowth$weight[PlantGrowth$group == "trt1"]
group3 <- PlantGrowth$weight[PlantGrowth$group == "trt2"]

result_list <- kwtest(list(group1, group2, group3))
print(result_list)

x_vector <- PlantGrowth$weight
g_vector <- factor(PlantGrowth$group)

result_vector <- kwtest(x_vector, g_vector)
print(result_vector)

```

### c.
Make a faster version of kwtest() that only computes the Kruskal-Wallis test statistic when the input is a numeric variable x and a variable g which gives the group membership. You can try simplifying the function above or by coding from the mathematical definition (see https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_one-way_analysis_of_variance). This function should also perform some checks to ensure the correctness of the inputs (use kwtest() as inspiration).
```{r}
kwtest_fast <- function(x, g) {
  if (!is.numeric(x) || !is.numeric(g) || length(x) != length(g)) {
    stop("'x' and 'g' must be numeric vectors of the same length")
  }
  if (length(unique(g)) < 2) {
    stop("At least two unique groups are required for Kruskal-Wallis test")
  }
  ranks <- rank(x)
  group_sums <- tapply(ranks, g, sum)
  group_sizes <- tapply(ranks, g, length)
  
  n <- length(x)
  k <- length(unique(g))
  H <- (12 / (n * (n + 1))) * sum(group_sums^2 / group_sizes) - 3 * (n + 1)
  
  df <- k - 1
  
  p_value <- pchisq(H, df, lower.tail = FALSE)
  
  result <- list(
    statistic = H,
    parameter = df,
    p.value = p_value,
    method = "Kruskal-Wallis rank sum test"
  )
  
  return(result)
}
```

### d.
Consider the following scenario. You have samples available from multiple experiments m = 1000 where you
collect the numerical values for the quantity of interest x and the group membership for n individuals. The
first 20 individuals in each sample belong to group 1, the following 20 individuals in each sample belong to
group 2, the last 10 individuals in each sample belong to group 3. Use the following code to simulate such a
data structure:
```
set.seed(1234)
m <- 1000 # number of repetitions
n <- 50 # number of individuals
X <- matrix(rt(m * n, df = 10), nrow = m)
grp <- rep(1:3, c(20, 20, 10))
```
Write a function which performs the Kruskal-Wallis test using the function stats:::kruskal.test.default() for m repeated experiments and returns a vector of m test statistics. The input of this function are a matrix X with m rows and n columns and a vector g which gives the grouping.
```{r}
perform_kruskal_wallis_tests <- function(X, g, fun) {
  split_X <- split(X, seq_len(nrow(X)))
  
  test_results <- lapply(split_X, function(experiment_data) {
    fun(experiment_data, g)
  })
  
  test_statistics <- sapply(test_results, function(result) result$statistic)
  return(unname(test_statistics))
}

set.seed(1234)
m <- 1000 # number of repetitions
n <- 50 # number of individuals
X <- matrix(rt(m * n, df = 10), nrow = m)
grp <- rep(1:3, c(20, 20, 10))

test_statistics <- perform_kruskal_wallis_tests(
  X, grp, stats:::kruskal.test.default)
head(test_statistics)

```

### e.
Write a function which performs the Kruskal-Wallis test using the function in point c. for m repeated experiments and returns a vector of m test statistics. The input of this function are a matrix X with m rows and n columns and a vector g which gives the grouping.
```{r}
test_statistics <- perform_kruskal_wallis_tests(X, grp, kwtest_fast)
head(test_statistics)
```

### f.
Compare the performance of the two approaches using a benchmarking package on the data generated above. Comment on the results.
```{r}
set.seed(1234)
m <- 1000 # number of repetitions
n <- 50 # number of individuals
X <- matrix(rt(m * n, df = 10), nrow = m)
grp <- rep(1:3, c(20, 20, 10))
mark(
  perform_kruskal_wallis_tests(X, grp, stats:::kruskal.test.default), 
  perform_kruskal_wallis_tests(X, grp, kwtest_fast)
  )
```
The results of the benchmarking show a clear picture: The kwtest_fast implementation outperforms the original implementation in almost every metric. The median execution time is down to less than 50%, and also the allocated memory is dramatically lower. 

### g.
Now consider vectorizing the function in point c. Compare this approach to the other two. Comment on the results.
```{r}
kwtest_vectorized <- function(x, g) {
  if (!is.numeric(x) || !is.numeric(g) || length(x) != length(g)) {
    stop("'x' and 'g' must be numeric vectors of the same length")
  }
  if (length(unique(g)) < 2) {
    stop("At least two unique groups are required for Kruskal-Wallis test")
  }
  ranks <- rank(x)
  
  n <- length(x)
  k <- length(unique(g))
  H <- (12 / (n * (n + 1))) * sum(tapply(ranks, g, sum)^2 / 
                                    tapply(ranks, g, length)) - 3 * (n + 1)
  
  df <- k - 1
  
  p_value <- pchisq(H, df, lower.tail = FALSE)
  
  result <- list(
    statistic = H,
    parameter = df,
    p.value = p_value,
    method = "Kruskal-Wallis rank sum test"
  )
  
  return(result)
}

set.seed(1234)
m <- 1000 # number of repetitions
n <- 50 # number of individuals
X <- matrix(rt(m * n, df = 10), nrow = m)
grp <- rep(1:3, c(20, 20, 10))
mark(
  perform_kruskal_wallis_tests(X, grp, stats:::kruskal.test.default), 
  perform_kruskal_wallis_tests(X, grp, kwtest_fast),
  perform_kruskal_wallis_tests(X, grp, kwtest_vectorized)
  )
```
Vectorizing kwtest_fast() still leads to performance improvements, albeit not as dramatically as before. The median time still decreased, however the allocated memory increased slightly. In most use cases however, the decreased median time is of higher importance than the allocated memory.

